<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Coffee‚òï</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --coffee-bg: #1f130f;
      --coffee-panel: #2b1a14;
      --coffee-accent: #f5c38b;
      --coffee-accent-soft: #e3a86a;
      --coffee-text: #fdf5e6;
      --coffee-muted: #c9b39a;
      --coffee-chat-bg: #241510;
      --coffee-chat-border: #3a241a;
      --coffee-input-bg: #3a241a;
      --coffee-btn-bg: #f5c38b;
      --coffee-btn-text: #2b1a14;
      --coffee-danger: #ff6b6b;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #3b241a 0, #120806 55%);
      color: var(--coffee-text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .coffee-shell {
      background: var(--coffee-panel);
      border-radius: 16px;
      padding: 16px 18px 18px;
      width: 430px;
      max-width: 100%;
      box-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
      border: 1px solid #3a241a;
      position: relative;
      overflow: hidden;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 22px;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: var(--coffee-input-bg);
      color: var(--coffee-text);
      font-size: 14px;
    }

    input::placeholder {
      color: #a88a72;
    }

    button {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      background: var(--coffee-btn-bg);
      color: var(--coffee-btn-text);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease,
        background 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
      background: #ffd19f;
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .profile {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: #241510;
      border: 1px solid #3a241a;
      font-size: 14px;
      display: none;
    }

    .profile-line {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .profile-emoji {
      font-size: 20px;
    }

    .status {
      margin-top: 8px;
      font-size: 12px;
      color: var(--coffee-muted);
      min-height: 16px;
    }

    .error {
      color: var(--coffee-danger);
      font-size: 12px;
      margin-top: 4px;
      min-height: 14px;
    }

    .game-panel {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid #3a241a;
      display: none;
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: #3a241a;
      color: var(--coffee-text);
      font-size: 14px;
      margin-bottom: 6px;
    }

    .chat-shell {
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 8px;
      background: var(--coffee-chat-bg);
      border: 1px solid var(--coffee-chat-border);
      font-size: 12px;
    }

    .chat-log {
      max-height: 90px;
      overflow-y: auto;
      margin-bottom: 4px;
    }

    .chat-input-row {
      display: flex;
      gap: 4px;
    }

    .chat-input-row input {
      font-size: 12px;
      padding: 4px 6px;
    }

    .chat-input-row button {
      font-size: 12px;
      padding: 4px 6px;
    }

    .chat-msg-host {
      color: #ffd8a0;
    }

    .chat-msg-joiner {
      color: #c0e6ff;
    }

    .chat-msg-system {
      color: #ffb3b3;
    }

    .server-list {
      margin-top: 10px;
      padding: 6px 8px;
      border-radius: 8px;
      background: #241510;
      border: 1px solid #3a241a;
      font-size: 12px;
      display: none;
      max-height: 120px;
      overflow-y: auto;
    }

    .server-item {
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #3a241a;
      margin-bottom: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .server-item span {
      font-size: 11px;
    }

    .server-item:hover {
      background: #3a241a;
    }

    .lock-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 11px;
      color: var(--coffee-muted);
    }

    .lock-row label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }

    .lock-row input[type="checkbox"] {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    /* SOLO MODE PANEL (bottom-right) */
    .solo-panel {
      position: absolute;
      right: 8px;
      bottom: 48px;
      width: 220px;
      background: rgba(20, 10, 7, 0.96);
      border-radius: 12px;
      border: 1px solid #3a241a;
      padding: 8px 8px 10px;
      font-size: 11px;
      display: none;
      z-index: 19;
    }

    .solo-header {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .solo-close-btn {
      background: #f5c38b;
      color: #2b1a14;
      border: none;
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 10px;
      cursor: pointer;
    }

    .solo-toggle-btn {
      position: absolute;
      right: 8px;
      bottom: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      background: #f5c38b;
      color: #2b1a14;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      z-index: 20;
    }

    .solo-select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: #3a241a;
      color: var(--coffee-text);
      font-size: 11px;
      margin-bottom: 4px;
    }

    .solo-board {
      margin-top: 4px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      padding: 4px;
      background: #241510;
      min-height: 100px;
    }

    .solo-status {
      font-size: 11px;
      color: var(--coffee-muted);
      min-height: 14px;
    }

    /* Simple boards for games */
    .board {
      margin-top: 8px;
      display: grid;
      gap: 2px;
    }

    .board-cell {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      background: #3a241a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
    }

    .board-cell:hover {
      background: #4a2f20;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="coffee-shell">
    <h1>Coffee‚òï</h1>

    <div class="row">
      <input id="emojiInput" placeholder="Emoji" maxlength="4" />
      <input id="nameInput" placeholder="Name" maxlength="20" />
    </div>

    <div class="row">
      <button id="hostBtn">Make Coffee</button>
      <button id="joinBtn">Get Coffee‚òï</button>
    </div>

    <div class="profile" id="profileBox">
      <div class="profile-line">
        <span class="profile-emoji" id="profileEmoji">üôÇ</span>
        <span id="profileName">Coffee</span>
      </div>
      <div class="profile-line">
        <span id="profileDevice">üì± Device</span>
      </div>
    </div>

    <div class="status" id="status"></div>
    <div class="error" id="error"></div>

    <!-- Server list for joiners -->
    <div class="server-list" id="serverList"></div>

    <!-- Game room -->
    <div class="game-panel" id="gamePanel">
      <select id="gameCategorySelect">
        <option value="">Select mode‚Ä¶</option>
        <option value="competitive">2‚ÄëPlayer Games</option>
        <option value="teamwork">Teamwork Mode</option>
      </select>

      <select id="gameSelect">
        <option value="">Select a game‚Ä¶</option>
      </select>

      <div id="playerOrderRow" class="row">
        <select id="player1Select">
          <option value="host">Player 1: Host</option>
          <option value="joiner">Player 1: Joiner</option>
          <option value="random">Player 1: Random</option>
        </select>
        <select id="player2Select">
          <option value="joiner">Player 2: Joiner</option>
          <option value="host">Player 2: Host</option>
          <option value="random">Player 2: Random</option>
        </select>
      </div>

      <div class="lock-row">
        <label>
          <input type="checkbox" id="chatLockToggle" />
          <span>Lock chat (both lose chat)</span>
        </label>
      </div>

      <button id="startGameBtn">Start Game</button>

      <div id="boardContainer"></div>

      <div class="chat-shell">
        <div class="chat-log" id="chatLog"></div>
        <div class="chat-input-row" id="chatInputRow">
          <input id="chatInput" placeholder="Chat‚Ä¶" />
          <button id="chatSendBtn">Send</button>
        </div>
      </div>
    </div>

    <!-- SOLO MODE PANEL -->
    <div class="solo-panel" id="soloPanel">
      <div class="solo-header">
        <span>Solo Mode</span>
        <button id="soloCloseBtn" class="solo-close-btn">X</button>
      </div>
      <select id="soloGameSelect" class="solo-select">
        <option value="tictactoe">Tic-Tac-Toe</option>
        <option value="rps">Rock‚ÄìPaper‚ÄìScissors</option>
        <option value="connect4">Connect 4</option>
      </select>
      <select id="soloControlSelect" class="solo-select">
        <option value="both">Control: Both sides</option>
        <option value="ai">Control: AI opponent</option>
      </select>
      <div class="solo-board" id="soloBoard"></div>
      <div class="solo-status" id="soloStatus"></div>
    </div>

    <!-- SOLO BUTTON -->
    <button id="soloToggleBtn" class="solo-toggle-btn">SOLO</button>
  </div>

  <script>
    // DOM refs
    const emojiInput = document.getElementById("emojiInput");
    const nameInput = document.getElementById("nameInput");
    const hostBtn = document.getElementById("hostBtn");
    const joinBtn = document.getElementById("joinBtn");
    const profileBox = document.getElementById("profileBox");
    const profileEmoji = document.getElementById("profileEmoji");
    const profileName = document.getElementById("profileName");
    const profileDevice = document.getElementById("profileDevice");
    const statusEl = document.getElementById("status");
    const errorEl = document.getElementById("error");
    const serverListEl = document.getElementById("serverList");
    const gamePanel = document.getElementById("gamePanel");
    const gameCategorySelect = document.getElementById("gameCategorySelect");
    const gameSelect = document.getElementById("gameSelect");
    const player1Select = document.getElementById("player1Select");
    const player2Select = document.getElementById("player2Select");
    const chatLockToggle = document.getElementById("chatLockToggle");
    const startGameBtn = document.getElementById("startGameBtn");
    const boardContainer = document.getElementById("boardContainer");
    const chatLog = document.getElementById("chatLog");
    const chatInputRow = document.getElementById("chatInputRow");
    const chatInput = document.getElementById("chatInput");
    const chatSendBtn = document.getElementById("chatSendBtn");

    const soloToggleBtn = document.getElementById("soloToggleBtn");
    const soloCloseBtn = document.getElementById("soloCloseBtn");
    const soloPanel = document.getElementById("soloPanel");
    const soloGameSelect = document.getElementById("soloGameSelect");
    const soloControlSelect = document.getElementById("soloControlSelect");
    const soloBoard = document.getElementById("soloBoard");
    const soloStatus = document.getElementById("soloStatus");

    // State
    let isHost = false;
    let isConnected = false;
    let deviceRole = "host"; // "host" or "joiner"
    let currentGame = null;
    let currentCategory = null;

    // Placeholder Bluetooth objects (no real implementation here)
    let btDevice = null;
    let btServer = null;
    let btCharacteristic = null;

    function setStatus(msg) {
      statusEl.textContent = msg || "";
    }

    function setError(msg) {
      errorEl.textContent = msg || "";
    }

    function detectDeviceIcon() {
      const ua = navigator.userAgent || "";
      if (/Windows/i.test(ua)) return "üñ• Windows";
      if (/Macintosh|Mac OS X/i.test(ua)) return "üíªMac&CheeseüßÄ";
      if (/Android/i.test(ua)) return "üì± Android";
      if (/iPhone|iPad|iPod/i.test(ua)) return "üì± iOS";
      return "üéÆ Controller";
    }

    function isSingleEmoji(str) {
      if (!str) return false;
      const trimmed = str.trim();
      const codePoints = Array.from(trimmed);
      return codePoints.length === 1;
    }

    function validateName(str) {
      if (!str) return false;
      const trimmed = str.trim();
      if (!trimmed) return false;
      const spaceCount = (trimmed.match(/ /g) || []).length;
      if (spaceCount > 1) return false;
      if (!/^[A-Za-z0-9 ]+$/.test(trimmed)) return false;
      return true;
    }

    function updateProfile() {
      const emoji = emojiInput.value.trim();
      const nameRaw = nameInput.value.trim();

      if (!isSingleEmoji(emoji)) {
        setError("Emoji must be exactly one emoji.");
        profileBox.style.display = "none";
        return false;
      }

      if (!validateName(nameRaw)) {
        setError("Name must be letters/numbers, max one space.");
        profileBox.style.display = "none";
        return false;
      }

      let name = nameRaw;
      let deviceLine = detectDeviceIcon();

      if (name.endsWith("@%")) {
        name = name.slice(0, -2);
        deviceLine = "üòé";
      }

      profileEmoji.textContent = emoji;
      profileName.textContent = name || "Coffee";
      profileDevice.textContent = deviceLine;
      profileBox.style.display = "block";
      setError("");
      return true;
    }

    emojiInput.addEventListener("input", updateProfile);
    nameInput.addEventListener("input", updateProfile);

    // SOLO toggle
    soloToggleBtn.addEventListener("click", () => {
      if (soloPanel.style.display === "none" || soloPanel.style.display === "") {
        soloPanel.style.display = "block";
      } else {
        soloPanel.style.display = "none";
      }
    });

    soloCloseBtn.addEventListener("click", () => {
      soloPanel.style.display = "none";
    });

    // SOLO games (simple local implementations)
    function renderSoloTicTacToe() {
      soloBoard.innerHTML = "";
      soloStatus.textContent = "Tic-Tac-Toe (solo)";
      const board = document.createElement("div");
      board.className = "board";
      board.style.gridTemplateColumns = "repeat(3, 32px)";
      const cells = Array(9).fill(null);
      let current = "X";

      cells.forEach((_, i) => {
        const cell = document.createElement("div");
        cell.className = "board-cell";
        cell.addEventListener("click", () => {
          if (cells[i]) return;
          cells[i] = current;
          cell.textContent = current;
          current = current === "X" ? "O" : "X";
        });
        board.appendChild(cell);
      });

      soloBoard.appendChild(board);
    }

    function renderSoloRPS() {
      soloBoard.innerHTML = "";
      soloStatus.textContent = "Rock‚ÄìPaper‚ÄìScissors (solo)";
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.gap = "4px";

      ["ü™®", "üìÑ", "‚úÇÔ∏è"].forEach((sym) => {
        const btn = document.createElement("button");
        btn.textContent = sym;
        btn.style.flex = "1";
        btn.addEventListener("click", () => {
          const choices = ["ü™®", "üìÑ", "‚úÇÔ∏è"];
          const ai = choices[Math.floor(Math.random() * choices.length)];
          soloStatus.textContent = `You: ${sym} | AI: ${ai}`;
        });
        row.appendChild(btn);
      });

      soloBoard.appendChild(row);
    }

    function renderSoloConnect4() {
      soloBoard.innerHTML = "";
      soloStatus.textContent = "Connect 4 (solo)";
      const rows = 6;
      const cols = 7;
      const grid = Array.from({ length: rows }, () => Array(cols).fill(null));
      const board = document.createElement("div");
      board.className = "board";
      board.style.gridTemplateColumns = `repeat(${cols}, 32px)`;
      let current = "‚óè";

      function drop(col) {
        for (let r = rows - 1; r >= 0; r--) {
          if (!grid[r][col]) {
            grid[r][col] = current;
            render();
            current = current === "‚óè" ? "‚óã" : "‚óè";
            return;
          }
        }
      }

      function render() {
        board.innerHTML = "";
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const cell = document.createElement("div");
            cell.className = "board-cell";
            cell.textContent = grid[r][c] || "";
            cell.addEventListener("click", () => drop(c));
            board.appendChild(cell);
          }
        }
      }

      render();
      soloBoard.appendChild(board);
    }

    function renderSoloGame() {
      const game = soloGameSelect.value;
      if (game === "tictactoe") renderSoloTicTacToe();
      else if (game === "rps") renderSoloRPS();
      else if (game === "connect4") renderSoloConnect4();
    }

    soloGameSelect.addEventListener("change", renderSoloGame);
    soloControlSelect.addEventListener("change", renderSoloGame);
    renderSoloGame();

    // Chat
    function addChatMessage(text, type = "system") {
      const div = document.createElement("div");
      if (type === "host") div.className = "chat-msg-host";
      else if (type === "joiner") div.className = "chat-msg-joiner";
      else div.className = "chat-msg-system";
      div.textContent = text;
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    chatSendBtn.addEventListener("click", () => {
      const msg = chatInput.value.trim();
      if (!msg) return;
      const role = isHost ? "host" : "joiner";
      addChatMessage(msg, role);
      chatInput.value = "";
      // In real implementation, send over Bluetooth
    });

    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") chatSendBtn.click();
    });

    chatLockToggle.addEventListener("change", () => {
      const locked = chatLockToggle.checked;
      chatInputRow.style.display = locked ? "none" : "flex";
      addChatMessage(
        locked ? "Chat locked for both players." : "Chat unlocked for both players.",
        "system"
      );
      // In real implementation, sync lock state over Bluetooth
    });

    // Game category + game list
    const competitiveGames = [
      { value: "chess", label: "Chess" },
      { value: "tictactoe", label: "Tic-Tac-Toe" },
      { value: "connect4", label: "Connect 4" },
      { value: "battleship", label: "Battleship (Micro)" },
      { value: "reversi", label: "Othello / Reversi" },
      { value: "pong", label: "Pong Duel" },
      { value: "memory", label: "Memory Match" },
      { value: "dots", label: "Dots & Boxes" },
      { value: "wordduel", label: "Word Guess Duel" },
      { value: "codebreaker", label: "Code Breaker" },
      { value: "gridchase", label: "Grid Chase" },
      { value: "war", label: "War (Card Duel)" },
    ];

    const teamworkGames = [
      { value: "randompuzzle", label: "Random Teamwork Puzzle" },
      { value: "maze", label: "Co‚Äëop Maze Escape" },
      { value: "tilerush", label: "Co‚Äëop Tile Rush" },
      { value: "reaction", label: "Co‚Äëop Reaction Chain" },
      { value: "pattern", label: "Co‚Äëop Pattern Sync" },
      { value: "wordbuilder", label: "Co‚Äëop Word Builder" },
    ];

    function populateGameSelect(category) {
      gameSelect.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "Select a game‚Ä¶";
      gameSelect.appendChild(placeholder);

      const list = category === "competitive" ? competitiveGames : teamworkGames;
      list.forEach((g) => {
        const opt = document.createElement("option");
        opt.value = g.value;
        opt.textContent = g.label;
        gameSelect.appendChild(opt);
      });

      const showPlayerOrder = category === "competitive";
      document.getElementById("playerOrderRow").style.display = showPlayerOrder
        ? "flex"
        : "none";
    }

    gameCategorySelect.addEventListener("change", () => {
      currentCategory = gameCategorySelect.value || null;
      if (!currentCategory) {
        gameSelect.innerHTML = "";
        return;
      }
      populateGameSelect(currentCategory);
    });

    // Simple local boards for a few games (visual only)
    function renderTicTacToeBoard() {
      boardContainer.innerHTML = "";
      const board = document.createElement("div");
      board.className = "board";
      board.style.gridTemplateColumns = "repeat(3, 32px)";
      for (let i = 0; i < 9; i++) {
        const cell = document.createElement("div");
        cell.className = "board-cell";
        board.appendChild(cell);
      }
      boardContainer.appendChild(board);
    }

    function renderConnect4Board() {
      boardContainer.innerHTML = "";
      const rows = 6;
      const cols = 7;
      const board = document.createElement("div");
      board.className = "board";
      board.style.gridTemplateColumns = `repeat(${cols}, 32px)`;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.className = "board-cell";
          board.appendChild(cell);
        }
      }
      boardContainer.appendChild(board);
    }

    function renderRandomTeamworkPuzzle() {
      boardContainer.innerHTML = "";
      const size = 5;
      const board = document.createElement("div");
      board.className = "board";
      board.style.gridTemplateColumns = `repeat(${size}, 32px)`;
      const symbols = ["‚òÖ", "‚óè", "‚ñ≤", "‚ñ†", "‚óÜ"];
      for (let i = 0; i < size * size; i++) {
        const cell = document.createElement("div");
        cell.className = "board-cell";
        cell.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        board.appendChild(cell);
      }
      boardContainer.appendChild(board);
      addChatMessage("Random teamwork puzzle generated.", "system");
    }

    function renderGameBoard(gameId) {
      if (!gameId) {
        boardContainer.innerHTML = "";
        return;
      }
      if (gameId === "tictactoe") renderTicTacToeBoard();
      else if (gameId === "connect4") renderConnect4Board();
      else if (gameId === "randompuzzle") renderRandomTeamworkPuzzle();
      else {
        boardContainer.innerHTML = "";
        const msg = document.createElement("div");
        msg.style.fontSize = "12px";
        msg.style.color = "#c9b39a";
        msg.textContent = "Game UI placeholder (logic not implemented here).";
        boardContainer.appendChild(msg);
      }
    }

    startGameBtn.addEventListener("click", () => {
      if (!currentCategory) {
        setError("Select a mode first.");
        return;
      }
      const gameId = gameSelect.value;
      if (!gameId) {
        setError("Select a game first.");
        return;
      }
      setError("");
      currentGame = gameId;

      const p1 = player1Select.value;
      const p2 = player2Select.value;

      addChatMessage(
        `Host started "${gameSelect.options[gameSelect.selectedIndex].text}" (${currentCategory}).`,
        "system"
      );
      if (currentCategory === "competitive") {
        addChatMessage(
          `Player 1: ${p1.toUpperCase()} | Player 2: ${p2.toUpperCase()}`,
          "system"
        );
      } else {
        addChatMessage("Teamwork mode: both players cooperate.", "system");
      }

      renderGameBoard(gameId);
      // In real implementation, sync game start + settings over Bluetooth
    });

    // Server list (fake for now)
    function showFakeServerList() {
      serverListEl.innerHTML = "";
      const servers = [
        { emoji: "üôÇ", name: "Rin", device: "üì± Android", strength: "Strong" },
        { emoji: "üòé", name: "CoolHost", device: "üñ• Windows", strength: "Medium" },
        { emoji: "üêà", name: "CatCafe", device: "üíªMac&CheeseüßÄ", strength: "Weak" },
      ];
      servers.forEach((s) => {
        const item = document.createElement("div");
        item.className = "server-item";
        const left = document.createElement("span");
        left.textContent = `${s.emoji} ${s.name} ‚Äî ${s.device}`;
        const right = document.createElement("span");
        right.textContent = s.strength;
        item.appendChild(left);
        item.appendChild(right);
        item.addEventListener("click", () => {
          connectAsJoinerFake(s);
        });
        serverListEl.appendChild(item);
      });
      serverListEl.style.display = "block";
    }

    function connectAsJoinerFake(server) {
      setStatus(`Joining ${server.name}'s Coffee‚Ä¶`);
      serverListEl.style.display = "none";
      isHost = false;
      deviceRole = "joiner";
      isConnected = true;
      gamePanel.style.display = "block";
      addChatMessage(`Connected to ${server.emoji} ${server.name}.`, "system");
    }

    // Bluetooth host (placeholder)
    async function connectAsHost() {
      isHost = true;
      deviceRole = "host";
      // Real Web Bluetooth would go here
      setStatus("Hosting Coffee‚Ä¶ (Bluetooth pairing placeholder)");
      isConnected = true;
      gamePanel.style.display = "block";
      addChatMessage("You are now hosting Coffee.", "system");
    }

    hostBtn.addEventListener("click", () => {
      if (!navigator.bluetooth) {
        setStatus("Web Bluetooth not supported in this browser.");
        return;
      }
      if (!updateProfile()) return;
      setStatus("Starting Coffee host‚Ä¶");
      connectAsHost();
    });

    joinBtn.addEventListener("click", () => {
      if (!navigator.bluetooth) {
        setStatus("Web Bluetooth not supported in this browser.");
        return;
      }
      if (!updateProfile()) return;
      setStatus("Searching for Coffee servers‚Ä¶");
      showFakeServerList();
    });
  </script>
</body>
</html>      justify-content: center;
      padding: 16px;
    }

    .coffee-shell {
      background: var(--coffee-panel);
      border-radius: 16px;
      padding: 16px 18px 18px;
      width: 430px;
      max-width: 100%;
      box-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
      border: 1px solid #3a241a;
      position: relative;
      overflow: hidden;
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 22px;
    }

    .row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    input {
      flex: 1;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: var(--coffee-input-bg);
      color: var(--coffee-text);
      font-size: 14px;
    }

    input::placeholder {
      color: #a88a72;
    }

    button {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      background: var(--coffee-btn-bg);
      color: var(--coffee-btn-text);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.08s ease,
        background 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
      background: #ffd19f;
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    .profile {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: #241510;
      border: 1px solid #3a241a;
      font-size: 14px;
      display: none;
    }

    .profile-line {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .profile-emoji {
      font-size: 20px;
    }

    .status {
      margin-top: 8px;
      font-size: 12px;
      color: var(--coffee-muted);
      min-height: 16px;
    }

    .error {
      color: var(--coffee-danger);
      font-size: 12px;
      margin-top: 4px;
      min-height: 14px;
    }

    .game-panel {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid #3a241a;
      display: none;
    }

    select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: #3a241a;
      color: var(--coffee-text);
      font-size: 14px;
      margin-bottom: 6px;
    }

    .chat-shell {
      margin-top: 8px;
      padding: 6px 8px;
      border-radius: 8px;
      background: var(--coffee-chat-bg);
      border: 1px solid var(--coffee-chat-border);
      font-size: 12px;
    }

    .chat-log {
      max-height: 90px;
      overflow-y: auto;
      margin-bottom: 4px;
    }

    .chat-input-row {
      display: flex;
      gap: 4px;
    }

    .chat-input-row input {
      font-size: 12px;
      padding: 4px 6px;
    }

    .chat-input-row button {
      font-size: 12px;
      padding: 4px 6px;
    }

    .chat-msg-host {
      color: #ffd8a0;
    }

    .chat-msg-joiner {
      color: #c0e6ff;
    }

    .chat-msg-system {
      color: #ffb3b3;
    }

    /* SOLO MODE PANEL (bottom-right) */
    .solo-panel {
      position: absolute;
      right: 8px;
      bottom: 8px;
      width: 220px;
      background: rgba(20, 10, 7, 0.96);
      border-radius: 12px;
      border: 1px solid #3a241a;
      padding: 8px 8px 10px;
      font-size: 11px;
    }

    .solo-header {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .solo-select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      background: #3a241a;
      color: var(--coffee-text);
      font-size: 11px;
      margin-bottom: 4px;
    }

    .solo-board {
      margin-top: 4px;
      border-radius: 8px;
      border: 1px solid #3a241a;
      padding: 4px;
      background: #241510;
      min-height: 100px;
    }

    .ttt-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 2px;
      margin-bottom: 4px;
      justify-items: center;
    }

    .ttt-cell {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      background: #3a241a;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
    }

    .rps-row {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
    }

    .rps-btn {
      flex: 1;
      padding: 4px 4px;
      border-radius: 999px;
      border: none;
      background: #f5c38b;
      color: #2b1a14;
      font-size: 11px;
      cursor: pointer;
    }

    .c4-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
      margin-bottom: 4px;
      justify-items: center;
    }

    .c4-cell {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #3a241a;
      border: 1px solid #4a3022;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
    }

    .solo-status {
      font-size: 11px;
      color: var(--coffee-muted);
      min-height: 14px;
    }
  </style>
</head>
<body>
  <div class="coffee-shell">
    <h1>Coffee‚òï</h1>

    <div class="row">
      <input id="emojiInput" placeholder="Emoji" maxlength="4" />
      <input id="nameInput" placeholder="Name" maxlength="20" />
    </div>

    <div class="row">
      <button id="hostBtn">Make Coffee</button>
      <button id="joinBtn">Get Coffee‚òï</button>
    </div>

    <div class="profile" id="profileBox">
      <div class="profile-line">
        <span class="profile-emoji" id="profileEmoji">üôÇ</span>
        <span id="profileName">Coffee</span>
      </div>
      <div class="profile-line">
        <span id="profileDevice">üì± Device</span>
      </div>
    </div>

    <div class="status" id="status"></div>
    <div class="error" id="error"></div>

    <div class="game-panel" id="gamePanel">
      <select id="gameSelect">
        <option value="">Select a game‚Ä¶</option>
        <option value="tictactoe">Tic-Tac-Toe</option>
        <option value="connect4">Connect 4</option>
        <option value="rps">Rock‚ÄìPaper‚ÄìScissors</option>
        <option value="battleship">Battleship (Micro)</option>
        <option value="pong">Pong Duel</option>
        <option value="memory">Memory Match</option>
        <option value="dots">Dots & Boxes</option>
        <option value="reversi">Othello / Reversi</option>
        <option value="wordguess">Word Guess Duel</option>
        <option value="codebreaker">Code Breaker</option>
        <option value="gridchase">Grid Chase</option>
        <option value="war">War (Card Duel)</option>
        <option value="chess">Chess</option>
      </select>
      <button id="startGameBtn">Start Game</button>

      <div class="chat-shell">
        <div class="chat-log" id="chatLog"></div>
        <div class="chat-input-row">
          <input id="chatInput" placeholder="Chat‚Ä¶" />
          <button id="chatSendBtn">Send</button>
        </div>
      </div>
    </div>

    <!-- SOLO MODE PANEL -->
    <div class="solo-panel">
      <div class="solo-header">
        <span>Solo Mode</span>
      </div>
      <select id="soloGameSelect" class="solo-select">
        <option value="tictactoe">Tic-Tac-Toe</option>
        <option value="rps">Rock‚ÄìPaper‚ÄìScissors</option>
        <option value="connect4">Connect 4</option>
      </select>
      <select id="soloControlSelect" class="solo-select">
        <option value="both">Control: Both sides</option>
        <option value="ai">Control: AI opponent</option>
      </select>
      <div class="solo-board" id="soloBoard"></div>
      <div class="solo-status" id="soloStatus"></div>
    </div>
  </div>

  <script>
    // ===== ELEMENTS =====
    const emojiInput = document.getElementById("emojiInput");
    const nameInput = document.getElementById("nameInput");
    const hostBtn = document.getElementById("hostBtn");
    const joinBtn = document.getElementById("joinBtn");
    const profileBox = document.getElementById("profileBox");
    const profileEmojiEl = document.getElementById("profileEmoji");
    const profileNameEl = document.getElementById("profileName");
    const profileDeviceEl = document.getElementById("profileDevice");
    const statusEl = document.getElementById("status");
    const errorEl = document.getElementById("error");
    const gamePanel = document.getElementById("gamePanel");
    const gameSelect = document.getElementById("gameSelect");
    const startGameBtn = document.getElementById("startGameBtn");
    const chatLog = document.getElementById("chatLog");
    const chatInput = document.getElementById("chatInput");
    const chatSendBtn = document.getElementById("chatSendBtn");

    const soloGameSelect = document.getElementById("soloGameSelect");
    const soloControlSelect = document.getElementById("soloControlSelect");
    const soloBoard = document.getElementById("soloBoard");
    const soloStatus = document.getElementById("soloStatus");

    // ===== STATE =====
    let isHost = false;
    let device = null;
    let server = null;
    let characteristic = null;

    // Solo mode state
    // Tic-Tac-Toe
    let tttBoard = Array(9).fill(null);
    let tttCurrent = "X";
    let tttGameOver = false;

    // RPS
    let rpsLastPlayerMove = null;

    // Connect 4 (7 columns x 6 rows)
    const C4_COLS = 7;
    const C4_ROWS = 6;
    let c4Board = createEmptyC4Board();
    let c4Current = "R"; // R = player, Y = AI
    let c4GameOver = false;

    // ===== HELPERS =====
    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function setError(msg) {
      errorEl.textContent = msg || "";
    }

    function getDeviceLabel() {
      const ua = navigator.userAgent || "";
      if (/Android/i.test(ua)) return "üì± Android Phone";
      if (/iPhone|iPad|iPod/i.test(ua)) return "üì± iOS Device";
      if (/Windows/i.test(ua)) return "üíª Windows PC";
      if (/Macintosh/i.test(ua)) return "üíª Mac";
      return "üì± Device";
    }

    function isSingleEmoji(str) {
      if (!str) return false;
      const trimmed = str.trim();
      const cleaned = trimmed.replace(/[\uFE0F\u200D]/g, "");
      return [...cleaned].length === 1;
    }

    function isValidName(str) {
      if (!str) return false;
      const trimmed = str.trim();
      if (!/^[A-Za-z0-9 ]+$/.test(trimmed)) return false;
      const spaces = (trimmed.match(/ /g) || []).length;
      if (spaces > 1) return false;
      return true;
    }

    function updateProfile() {
      setError("");
      const emojiRaw = (emojiInput.value || "").trim();
      const nameRaw = (nameInput.value || "").trim();

      if (!isSingleEmoji(emojiRaw)) {
        setError("Emoji must be exactly 1 emoji.");
        profileBox.style.display = "none";
        return false;
      }

      const nameWithoutSecret = nameRaw.replace(/@%$/, "");
      if (!isValidName(nameWithoutSecret)) {
        setError("Name: letters/numbers, max 1 space, no symbols.");
        profileBox.style.display = "none";
        return false;
      }

      let emoji = emojiRaw;
      let rawName = nameRaw || "Coffee";

      let name = rawName;
      let specialCool = false;

      if (rawName.endsWith("@%")) {
        name = rawName.replace(/@%$/, "");
        specialCool = true;
      }

      profileEmojiEl.textContent = emoji;
      profileNameEl.textContent = name;

      if (specialCool) {
        profileDeviceEl.textContent = "üòé";
      } else {
        profileDeviceEl.textContent = getDeviceLabel();
      }

      profileBox.style.display = "block";
      return true;
    }

    function appendChat(from, text, kind = "normal") {
      const div = document.createElement("div");
      if (kind === "system") {
        div.className = "chat-msg-system";
        div.textContent = `[${from}] ${text}`;
      } else if (from === "Host") {
        div.className = "chat-msg-host";
        div.textContent = `Host: ${text}`;
      } else if (from === "Joiner") {
        div.className = "chat-msg-joiner";
        div.textContent = `Joiner: ${text}`;
      } else {
        div.textContent = `${from}: ${text}`;
      }
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function sendPacket(obj) {
      if (!characteristic) return;
      const data = new TextEncoder().encode(JSON.stringify(obj));
      characteristic.writeValue(data).catch((err) => {
        console.error("Write failed:", err);
      });
    }

    function handleMessage(dataView) {
      try {
        const text = new TextDecoder().decode(dataView);
        const msg = JSON.parse(text);

        if (msg.type === "chat") {
          appendChat(msg.from === "host" ? "Host" : "Joiner", msg.text);
        } else if (msg.type === "game-select") {
          gameSelect.value = msg.game;
        } else if (msg.type === "game-start") {
          appendChat("System", `Game started: ${msg.game}`, "system");
        }
      } catch (e) {
        console.log("Bad message", e);
      }
    }

    function sendChat(text) {
      const trimmed = text.trim();
      if (!trimmed) return;
      appendChat(isHost ? "Host" : "Joiner", trimmed);
      sendPacket({
        type: "chat",
        from: isHost ? "host" : "joiner",
        text: trimmed,
      });
      chatInput.value = "";
    }

    // ===== BLUETOOTH SETUP =====
    const SERVICE_UUID = "0000ffe0-0000-1000-8000-00805f9b34fb";
    const CHAR_UUID = "0000ffe1-0000-1000-8000-00805f9b34fb";

    async function connectAsHost() {
      isHost = true;
      if (!updateProfile()) return;
      setStatus("Requesting Bluetooth device as host‚Ä¶");

      try {
        const dev = await navigator.bluetooth.requestDevice({
          filters: [{ services: [SERVICE_UUID] }],
          optionalServices: [SERVICE_UUID],
        });
        device = dev;
        setStatus(`Connecting to ${dev.name || "device"}‚Ä¶`);
        const gatt = await dev.gatt.connect();
        server = gatt;
        const service = await server.getPrimaryService(SERVICE_UUID);
        const char = await service.getCharacteristic(CHAR_UUID);
        characteristic = char;

        await characteristic.startNotifications();
        characteristic.addEventListener("characteristicvaluechanged", (event) =>
          handleMessage(event.target.value)
        );

        setStatus("Host connected. Waiting in Coffee server‚Ä¶");
        gamePanel.style.display = "block";
      } catch (err) {
        console.error(err);
        setStatus("Host Bluetooth failed or was cancelled.");
      }
    }

    async function connectAsJoiner() {
      isHost = false;
      if (!updateProfile()) return;
      setStatus("Searching for Coffee host‚Ä¶");

      try {
        const dev = await navigator.bluetooth.requestDevice({
          filters: [{ services: [SERVICE_UUID] }],
          optionalServices: [SERVICE_UUID],
        });
        device = dev;
        setStatus(`Connecting to ${dev.name || "host"}‚Ä¶`);
        const gatt = await dev.gatt.connect();
        server = gatt;
        const service = await server.getPrimaryService(SERVICE_UUID);
        const char = await service.getCharacteristic(CHAR_UUID);
        characteristic = char;

        await characteristic.startNotifications();
        characteristic.addEventListener("characteristicvaluechanged", (event) =>
          handleMessage(event.target.value)
        );

        setStatus("Joined Coffee server.");
        gamePanel.style.display = "block";
      } catch (err) {
        console.error(err);
        setStatus("Join Bluetooth failed or was cancelled.");
      }
    }

    // ===== EVENTS =====
    hostBtn.addEventListener("click", () => {
      if (!navigator.bluetooth) {
        setStatus("Web Bluetooth not supported in this browser.");
        return;
      }
      connectAsHost();
    });

    joinBtn.addEventListener("click", () => {
      if (!navigator.bluetooth) {
        setStatus("Web Bluetooth not supported in this browser.");
        return;
      }
      connectAsJoiner();
    });

    gameSelect.addEventListener("change", () => {
      if (!isHost || !characteristic) return;
      const game = gameSelect.value;
      sendPacket({ type: "game-select", game });
    });

    startGameBtn.addEventListener("click", () => {
      if (!isHost || !characteristic) return;
      const game = gameSelect.value;
      if (!game) return;
      sendPacket({ type: "game-start", game });
      appendChat("System", `Game started: ${game}`, "system");
    });

    chatSendBtn.addEventListener("click", () => {
      sendChat(chatInput.value);
    });

    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendChat(chatInput.value);
      }
    });

    // ===== SOLO MODE: GAME SWITCHER =====
    soloGameSelect.addEventListener("change", renderSoloGame);
    soloControlSelect.addEventListener("change", () => {
      const game = soloGameSelect.value;
      if (game === "tictactoe") {
        resetTicTacToe();
        renderTicTacToe();
      } else if (game === "rps") {
        renderRPS();
      } else if (game === "connect4") {
        resetConnect4();
        renderConnect4();
      }
    });

    function renderSoloGame() {
      const game = soloGameSelect.value;
      if (game === "tictactoe") {
        resetTicTacToe();
        renderTicTacToe();
      } else if (game === "rps") {
        renderRPS();
      } else if (game === "connect4") {
        resetConnect4();
        renderConnect4();
      }
    }

    // ===== SOLO MODE: TIC-TAC-TOE WITH MINIMAX AI =====
    function resetTicTacToe() {
      tttBoard = Array(9).fill(null);
      tttCurrent = "X";
      tttGameOver = false;
      soloStatus.textContent = "Tic-Tac-Toe: X starts.";
    }

    function renderTicTacToe() {
      soloBoard.innerHTML = "";
      const grid = document.createElement("div");
      grid.className = "ttt-grid";

      tttBoard.forEach((cell, idx) => {
        const div = document.createElement("div");
        div.className = "ttt-cell";
        div.textContent = cell || "";
        div.addEventListener("click", () => handleTicTacToeClick(idx));
        grid.appendChild(div);
      });

      soloBoard.appendChild(grid);
    }

    function handleTicTacToeClick(idx) {
      if (tttGameOver) return;
      if (tttBoard[idx]) return;

      const control = soloControlSelect.value;

      if (control === "both") {
        tttBoard[idx] = tttCurrent;
        tttCurrent = tttCurrent === "X" ? "O" : "X";
        checkTicTacToeState();
        renderTicTacToe();
      } else {
        if (tttCurrent !== "X") return;
        tttBoard[idx] = "X";
        checkTicTacToeState();
        renderTicTacToe();
        if (!tttGameOver) {
          tttCurrent = "O";
          ticTacToeAIMove();
        }
      }
    }

    function checkTicTacToeState() {
      const winner = getTicTacToeWinner(tttBoard);
      if (winner) {
        tttGameOver = true;
        soloStatus.textContent = `Tic-Tac-Toe: ${winner} wins!`;
      } else if (tttBoard.every((c) => c)) {
        tttGameOver = true;
        soloStatus.textContent = "Tic-Tac-Toe: Draw.";
      } else {
        if (!tttGameOver) {
          soloStatus.textContent = `Tic-Tac-Toe: ${tttCurrent}'s turn.`;
        }
      }
    }

    function getTicTacToeWinner(board) {
      const lines = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6],
      ];
      for (const [a, b, c] of lines) {
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
          return board[a];
        }
      }
      return null;
    }

    function ticTacToeAIMove() {
      const best = minimax(tttBoard, "O");
      if (best.index !== null && !tttBoard[best.index]) {
        tttBoard[best.index] = "O";
      }
      checkTicTacToeState();
      renderTicTacToe();
      if (!tttGameOver) {
        tttCurrent = "X";
      }
    }

    function minimax(board, player) {
      const winner = getTicTacToeWinner(board);
      if (winner === "X") return { score: -10, index: null };
      if (winner === "O") return { score: 10, index: null };
      if (board.every((c) => c)) return { score: 0, index: null };

      const moves = [];
      for (let i = 0; i < 9; i++) {
        if (!board[i]) {
          const newBoard = board.slice();
          newBoard[i] = player;
          const result = minimax(newBoard, player === "O" ? "X" : "O");
          moves.push({ index: i, score: result.score });
        }
      }

      let bestMove;
      if (player === "O") {
        let bestScore = -Infinity;
        for (const move of moves) {
          if (move.score > bestScore) {
            bestScore = move.score;
            bestMove = move;
          }
        }
      } else {
        let bestScore = Infinity;
        for (const move of moves) {
          if (move.score < bestScore) {
            bestScore = move.score;
            bestMove = move;
          }
        }
      }
      return bestMove || { score: 0, index: null };
    }

    // ===== SOLO MODE: ROCK‚ÄìPAPER‚ÄìSCISSORS WITH ADAPTIVE AI =====
    function renderRPS() {
      soloBoard.innerHTML = "";

      const row = document.createElement("div");
      row.className = "rps-row";

      const moves = ["Rock", "Paper", "Scissors"];
      moves.forEach((m) => {
        const btn = document.createElement("button");
        btn.className = "rps-btn";
        btn.textContent = m;
        btn.addEventListener("click", () => handleRPSClick(m));
        row.appendChild(btn);
      });

      soloBoard.appendChild(row);
      soloStatus.textContent = "RPS: Choose your move.";
    }

    function handleRPSClick(playerMove) {
      const control = soloControlSelect.value;
      let aiMove;

      if (control === "both") {
        aiMove = randomRPS();
      } else {
        aiMove = strategicRPS(playerMove);
      }

      const result = rpsResult(playerMove, aiMove);
      rpsLastPlayerMove = playerMove;

      soloStatus.textContent = `You: ${playerMove} | Opponent: ${aiMove} ‚Üí ${result}`;
    }

    function randomRPS() {
      const moves = ["Rock", "Paper", "Scissors"];
      return moves[Math.floor(Math.random() * moves.length)];
    }

    function strategicRPS(playerMove) {
      const target = rpsLastPlayerMove || playerMove;
      if (target === "Rock") return "Paper";
      if (target === "Paper") return "Scissors";
      if (target === "Scissors") return "Rock";
      return randomRPS();
    }

    function rpsResult(p, a) {
      if (p === a) return "Draw";
      if (
        (p === "Rock" && a === "Scissors") ||
        (p === "Paper" && a === "Rock") ||
        (p === "Scissors" && a === "Paper")
      ) {
        return "You win!";
      }
      return "You lose.";
    }

    // ===== SOLO MODE: CONNECT 4 WITH DEPTH-LIMITED MINIMAX AI =====
    function createEmptyC4Board() {
      const board = [];
      for (let r = 0; r < C4_ROWS; r++) {
        const row = [];
        for (let c = 0; c < C4_COLS; c++) {
          row.push(null);
        }
        board.push(row);
      }
      return board;
    }

    function resetConnect4() {
      c4Board = createEmptyC4Board();
      c4Current = "R"; // player
      c4GameOver = false;
      soloStatus.textContent = "Connect 4: Red (you) starts.";
    }

    function renderConnect4() {
      soloBoard.innerHTML = "";
      const grid = document.createElement("div");
      grid.className = "c4-grid";

      for (let r = 0; r < C4_ROWS; r++) {
        for (let c = 0; c < C4_COLS; c++) {
          const cell = document.createElement("div");
          cell.className = "c4-cell";
          const val = c4Board[r][c];
          if (val === "R") cell.style.background = "#ff4b4b";
          if (val === "Y") cell.style.background = "#ffd93b";
          cell.addEventListener("click", () => handleC4Click(c));
          grid.appendChild(cell);
        }
      }

      soloBoard.appendChild(grid);
    }

    function handleC4Click(col) {
      if (c4GameOver) return;

      const control = soloControlSelect.value;

      if (control === "both") {
        if (!dropC4Piece(c4Board, col, c4Current)) return;
        const winner = checkC4Winner(c4Board);
        if (winner || isC4Full(c4Board)) {
          c4GameOver = true;
          if (winner) {
            soloStatus.textContent = `Connect 4: ${winner === "R" ? "Red" : "Yellow"} wins!`;
          } else {
            soloStatus.textContent = "Connect 4: Draw.";
          }
        } else {
          c4Current = c4Current === "R" ? "Y" : "R";
          soloStatus.textContent = `Connect 4: ${c4Current === "R" ? "Red" : "Yellow"}'s turn.`;
        }
        renderConnect4();
      } else {
        // player = R, AI = Y
        if (c4Current !== "R") return;
        if (!dropC4Piece(c4Board, col, "R")) return;
        let winner = checkC4Winner(c4Board);
        if (winner || isC4Full(c4Board)) {
          c4GameOver = true;
          if (winner) {
            soloStatus.textContent = `Connect 4: ${winner === "R" ? "You win!" : "AI wins!"}`;
          } else {
            soloStatus.textContent = "Connect 4: Draw.";
          }
          renderConnect4();
          return;
        }
        c4Current = "Y";
        renderConnect4();
        connect4AIMove();
      }
    }

    function dropC4Piece(board, col, player) {
      for (let r = C4_ROWS - 1; r >= 0; r--) {
        if (!board[r][col]) {
          board[r][col] = player;
          return true;
        }
      }
      return false;
    }

    function isC4Full(board) {
      for (let c = 0; c < C4_COLS; c++) {
        if (!board[0][c]) return false;
      }
      return true;
    }

    function checkC4Winner(board) {
      // horizontal, vertical, diagonal
      for (let r = 0; r < C4_ROWS; r++) {
        for (let c = 0; c < C4_COLS; c++) {
          const player = board[r][c];
          if (!player) continue;

          // right
          if (c + 3 < C4_COLS &&
              player === board[r][c+1] &&
              player === board[r][c+2] &&
              player === board[r][c+3]) return player;

          // down
          if (r + 3 < C4_ROWS &&
              player === board[r+1][c] &&
              player === board[r+2][c] &&
              player === board[r+3][c]) return player;

          // diag down-right
          if (r + 3 < C4_ROWS && c + 3 < C4_COLS &&
              player === board[r+1][c+1] &&
              player === board[r+2][c+2] &&
              player === board[r+3][c+3]) return player;

          // diag down-left
          if (r + 3 < C4_ROWS && c - 3 >= 0 &&
              player === board[r+1][c-1] &&
              player === board[r+2][c-2] &&
              player === board[r+3][c-3]) return player;
        }
      }
      return null;
    }

    function evaluateC4Board(board) {
      // simple heuristic: +score for AI (Y), -score for player (R)
      let score = 0;

      function scoreLine(a, b, c, d) {
        const line = [a, b, c, d];
        const yCount = line.filter((x) => x === "Y").length;
        const rCount = line.filter((x) => x === "R").length;
        if (yCount > 0 && rCount === 0) {
          if (yCount === 2) score += 2;
          if (yCount === 3) score += 5;
        }
        if (rCount > 0 && yCount === 0) {
          if (rCount === 2) score -= 2;
          if (rCount === 3) score -= 5;
        }
      }

      for (let r = 0; r < C4_ROWS; r++) {
        for (let c = 0; c < C4_COLS; c++) {
          if (c + 3 < C4_COLS) {
            scoreLine(board[r][c], board[r][c+1], board[r][c+2], board[r][c+3]);
          }
          if (r + 3 < C4_ROWS) {
            scoreLine(board[r][c], board[r+1][c], board[r+2][c], board[r+3][c]);
          }
          if (r + 3 < C4_ROWS && c + 3 < C4_COLS) {
            scoreLine(board[r][c], board[r+1][c+1], board[r+2][c+2], board[r+3][c+3]);
          }
          if (r + 3 < C4_ROWS && c - 3 >= 0) {
            scoreLine(board[r][c], board[r+1][c-1], board[r+2][c-2], board[r+3][c-3]);
          }
        }
      }

      return score;
    }

    function cloneC4Board(board) {
      return board.map((row) => row.slice());
    }

    function connect4AIMove() {
      const depth = 4; // depth-limited
      let bestScore = -Infinity;
      let bestCol = null;

      for (let c = 0; c < C4_COLS; c++) {
        const tempBoard = cloneC4Board(c4Board);
        if (!dropC4Piece(tempBoard, c, "Y")) continue;
        const score = c4Minimax(tempBoard, depth - 1, false, -Infinity, Infinity);
        if (score > bestScore) {
          bestScore = score;
          bestCol = c;
        }
      }

      if (bestCol !== null) {
        dropC4Piece(c4Board, bestCol, "Y");
      }

      const winner = checkC4Winner(c4Board);
      if (winner || isC4Full(c4Board)) {
        c4GameOver = true;
        if (winner) {
          soloStatus.textContent = `Connect 4: ${winner === "Y" ? "AI wins!" : "You win!"}`;
        } else {
          soloStatus.textContent = "Connect 4: Draw.";
        }
      } else {
        c4Current = "R";
        soloStatus.textContent = "Connect 4: Your turn (Red).";
      }
      renderConnect4();
    }

    function c4Minimax(board, depth, maximizing, alpha, beta) {
      const winner = checkC4Winner(board);
      if (winner === "Y") return 1000;
      if (winner === "R") return -1000;
      if (isC4Full(board) || depth === 0) {
        return evaluateC4Board(board);
      }

      if (maximizing) {
        let maxEval = -Infinity;
        for (let c = 0; c < C4_COLS; c++) {
          const temp = cloneC4Board(board);
          if (!dropC4Piece(temp, c, "Y")) continue;
          const evalScore = c4Minimax(temp, depth - 1, false, alpha, beta);
          maxEval = Math.max(maxEval, evalScore);
          alpha = Math.max(alpha, evalScore);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (let c = 0; c < C4_COLS; c++) {
          const temp = cloneC4Board(board);
          if (!dropC4Piece(temp, c, "R")) continue;
          const evalScore = c4Minimax(temp, depth - 1, true, alpha, beta);
          minEval = Math.min(minEval, evalScore);
          beta = Math.min(beta, evalScore);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    // ===== INITIALIZE SOLO MODE =====
    renderSoloGame();
  </script>
</body>
</html>

